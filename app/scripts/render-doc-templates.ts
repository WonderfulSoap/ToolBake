/**
 * Script to process *.md.template files and generate *.md with dynamic content.
 * Scans docs-site/docs for template files and replaces {{{{xxxx}}}} placeholders.
 * Usage: npm run gen:widgets-doc
 */
import fs from "node:fs";
import path from "node:path";
import { buildUiWidgetsDocusaurusMarkdown } from "~/components/input-widgets/input-types";
import { getEmbeddedPackagesMdTable } from "~/config/embedded-packages";
import { ToolBakePrompt } from "~/data/llm/openai-client/llm-prompt";

const DOCS_DIR = path.resolve(import.meta.dirname, "../../docs-site/docs");

// Placeholder renderers: add new placeholders here as needed
const placeholderRenderers: Record<string, () => string> = {
  "uiWidgets reference"  : buildUiWidgetsDocusaurusMarkdown,
  "embedded package list": getEmbeddedPackagesMdTable,
  "user tool prompt"     : () => new ToolBakePrompt().buildCreateUserToolSystemPrompt(),
};

/** Recursively find all *.md.template files under a directory */
function findTemplateFiles(dir: string): string[] {
  const results: string[] = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...findTemplateFiles(fullPath));
    } else if (entry.isFile() && entry.name.endsWith(".md.template")) {
      results.push(fullPath);
    }
  }
  return results;
}

/** Replace all {{{{key}}}} placeholders in content */
function renderTemplate(content: string): string {
  return content.replace(/\{\{\{\{(.+?)\}\}\}\}/g, (match, key: string) => {
    const renderer = placeholderRenderers[key.trim()];
    if (!renderer) {
      console.warn(`Unknown placeholder: ${match}`);
      return match;
    }
    return renderer();
  });
}

/** Insert auto-generated warning comment after the first # heading */
function insertAutoGenComment(content: string, templatePath: string): string {
  const relativePath = path.relative(process.cwd(), templatePath);
  const comment = `{/* Auto-generated from ${relativePath}. Do not edit this file directly. */}`;
  // Find the first # heading line and insert comment after it
  const headingMatch = content.match(/^([\s\S]*?)(^#[^\n]*\n)/m);
  if (headingMatch) {
    const before = headingMatch[1];
    const heading = headingMatch[2];
    const rest = content.slice(before.length + heading.length);
    return `${before}${heading}\n${comment}\n${rest}`;
  }
  // No heading found, prepend comment
  return `${comment}\n\n${content}`;
}

function main() {
  const templates = findTemplateFiles(DOCS_DIR);
  if (templates.length === 0) {
    console.log("No *.md.template files found.");
    return;
  }
  for (const tpl of templates) {
    const outputPath = tpl.replace(/\.md\.template$/, ".md");
    const content = fs.readFileSync(tpl, "utf-8");
    const rendered = renderTemplate(content);
    const withComment = insertAutoGenComment(rendered, tpl);
    fs.writeFileSync(outputPath, withComment, "utf-8");
    console.log(`Generated: ${path.relative(process.cwd(), outputPath)}`);
  }
}

main();
