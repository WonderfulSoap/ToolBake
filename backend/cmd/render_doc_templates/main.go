package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"ya-tool-craft/internal/config"
)

const docsDir = "../docs-site/docs"

var placeholderPattern = regexp.MustCompile(`\{\{\{\{(.+?)\}\}\}\}`)

var placeholderRenderers = map[string]func() string{
	"config env table": func() string {
		return config.Config{}.DumpEnvDefaultsMarkdownTable()
	},
}

func main() {
	templates, err := findTemplateFiles(docsDir)
	if err != nil {
		fmt.Printf("failed to find template files: %v\n", err)
		os.Exit(1)
	}

	if len(templates) == 0 {
		fmt.Println("No *.md.template files found.")
		return
	}

	renderedCount := 0
	for _, tpl := range templates {
		content, err := os.ReadFile(tpl)
		if err != nil {
			fmt.Printf("failed to read template %s: %v\n", tpl, err)
			os.Exit(1)
		}

		rendered, shouldRender := renderTemplate(string(content))
		if !shouldRender {
			continue
		}

		outputPath := strings.TrimSuffix(tpl, ".template")
		withComment, err := insertAutoGenComment(rendered, tpl)
		if err != nil {
			fmt.Printf("failed to insert auto-generated comment for %s: %v\n", tpl, err)
			os.Exit(1)
		}

		if err := os.WriteFile(outputPath, []byte(withComment), 0644); err != nil {
			fmt.Printf("failed to write rendered output %s: %v\n", outputPath, err)
			os.Exit(1)
		}

		relativeOutputPath := outputPath
		if cwd, err := os.Getwd(); err == nil {
			if relPath, relErr := filepath.Rel(cwd, outputPath); relErr == nil {
				relativeOutputPath = relPath
			}
		}
		fmt.Printf("Generated: %s\n", relativeOutputPath)
		renderedCount++
	}

	if renderedCount == 0 {
		fmt.Println("No matching placeholders found for this renderer.")
	}
}

func findTemplateFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if strings.HasSuffix(d.Name(), ".md.template") {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

func renderTemplate(content string) (string, bool) {
	matches := placeholderPattern.FindAllStringSubmatch(content, -1)
	if len(matches) == 0 {
		return content, false
	}

	hasKnownPlaceholder := false
	for _, submatch := range matches {
		key := strings.TrimSpace(submatch[1])
		if _, ok := placeholderRenderers[key]; ok {
			hasKnownPlaceholder = true
			continue
		}
		return content, false
	}
	if !hasKnownPlaceholder {
		return content, false
	}

	rendered := placeholderPattern.ReplaceAllStringFunc(content, func(match string) string {
		submatches := placeholderPattern.FindStringSubmatch(match)
		if len(submatches) != 2 {
			return match
		}
		key := strings.TrimSpace(submatches[1])
		renderer, ok := placeholderRenderers[key]
		if !ok {
			return match
		}
		return renderer()
	})
	return rendered, true
}

func insertAutoGenComment(content, templatePath string) (string, error) {
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	absTemplatePath, err := filepath.Abs(templatePath)
	if err != nil {
		return "", err
	}

	relativePath, err := filepath.Rel(cwd, absTemplatePath)
	if err != nil {
		return "", err
	}
	comment := fmt.Sprintf("{/* Auto-generated from %s. Do not edit this file directly. */}", relativePath)

	lines := strings.Split(content, "\n")
	for i, line := range lines {
		if strings.HasPrefix(line, "#") {
			withComment := make([]string, 0, len(lines)+1)
			withComment = append(withComment, lines[:i+1]...)
			withComment = append(withComment, "")
			withComment = append(withComment, comment)
			withComment = append(withComment, lines[i+1:]...)
			return strings.Join(withComment, "\n"), nil
		}
	}

	return comment + "\n\n" + content, nil
}
